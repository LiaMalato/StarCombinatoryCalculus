import LeanProjeto2.FOLanguage
import LeanProjeto2.StarLanguage.Axioms
import LeanProjeto2.StarLanguage.Syntax
import LeanProjeto2.StarLanguage.FiniteTypes
import LeanProjeto2.SHFunctInterp
import MathLib.Tactic
import Mathlib.Data.Finset.Basic
import Mathlib.Data.Multiset.Basic
import Batteries

open LFormula
open Term
open Formula
open Set
open Batteries




-- ---------------------------------------------------------------------------------
-- ---------------------------------------------------------------------------------
-- ---------------------------------------------------------------------------------
-- ---------------------------------------------------------------------------------

/- ----------------------------------------
      Lambda abstraction through terms
-/ ----------------------------------------

inductive lambda : Type
| la (s : String) (body : Term): lambda

def lambda.to_term : lambda ‚Üí Term
| .la _ Œ†‚ÇÅ => Œ†‚ÇÅ¬∑Œ†‚ÇÅ
| .la _ Œ£‚ÇÅ => Œ†‚ÇÅ¬∑Œ£‚ÇÅ
| .la _ ind_‚ãÉ‚ÇÅ => Œ†‚ÇÅ¬∑ind_‚ãÉ‚ÇÅ
| .la _ ‚à™‚ÇÅ => Œ†‚ÇÅ¬∑‚à™‚ÇÅ
| .la _ ùî∞‚ÇÅ => Œ†‚ÇÅ¬∑ùî∞‚ÇÅ
| .la _ (lcons k) => Œ†‚ÇÅ¬∑(lcons k)
| .la _ (lfun f) => Œ†‚ÇÅ¬∑(lfun f)
| .la x (var y) => if x=y then ((Œ£‚ÇÅ¬∑Œ†‚ÇÅ)¬∑Œ†‚ÇÅ) else (Œ†‚ÇÅ¬∑(var y))
| .la x (t¬∑s) => ((Œ£‚ÇÅ¬∑(lambda.la x t).to_term)¬∑(lambda.la x s).to_term)

def testu := lambda.la "y" .pi
def testu2 := lambda.la "x" (lambda.la "y" .pi).to_term
def testu3 := lambda.la "x" (lambda.la "y" ((lambda.la "z" .pi).to_term)).to_term
#eval testu.to_term
#eval testu2.to_term
#eval testu3.to_term

def lambdas_no (fs: List String) (bodies: List Term) : List lambda :=
  (fs.zip bodies).map ( fun (f, b) => lambda.la f b)

def lambdas : List String ‚Üí Term ‚Üí Term
| [], body => body                                         -- sem vari√°veis, n√£o acontece nada
| f :: fs, body => (lambda.la f (lambdas fs body)).to_term -- recursively nesting lambda abstractions

notation "Œª‚ÇÅ‚ÇÅ" => lambdas

#eval Œª‚ÇÅ‚ÇÅ ["x", "y"] .pi
#eval Œª‚ÇÅ‚ÇÅ ["x"] .pi

-- Define lambdas_tuple
def lambdas_tuple : List String ‚Üí List Term ‚Üí List Term
| vars, ts => ts.map (Œª t => lambdas vars t)
  -- Apply lambdas to each term in the list ts using the list of variables vars

notation "Œª‚ÇÅ" => lambdas_tuple

-- EXEMPLO:
#eval Œª‚ÇÅ ["x1", "x2"] [.pi, .sigma, .sing]
#eval Œª‚ÇÅ ["x", "y"] [.pi, .sigma]


-- ------------------------------------------------------------

/- ----------------------------------------
      Conversions
-/ ----------------------------------------

open lambda

#eval ((la "x" Œ†‚ÇÅ).to_term)                     -- a tirar

inductive conversion : Type                     -- a tirar
| c1 (t‚ÇÅ t‚ÇÇ : Term) : conversion
| c2 (t‚ÇÅ t‚ÇÇ t‚ÇÉ : Term) : conversion
| c3 (t‚ÇÅ t‚ÇÇ : Term) : conversion
| c4 (t‚ÇÅ t‚ÇÇ t‚ÇÉ : Term) : conversion

def conversion.to_Term : conversion ‚Üí Term      -- a tirar
| .c1 t‚ÇÅ t‚ÇÇ => t‚ÇÅ
| .c2 t‚ÇÅ t‚ÇÇ t‚ÇÉ => ((t‚ÇÅ¬∑t‚ÇÉ)¬∑(t‚ÇÇ¬∑t‚ÇÉ))
| .c3 t‚ÇÅ t‚ÇÇ => (t‚ÇÇ¬∑t‚ÇÅ)
| .c4 t‚ÇÅ t‚ÇÇ t‚ÇÉ => (‚à™‚ÇÅ¬∑((ind_‚ãÉ‚ÇÅ¬∑t‚ÇÅ)¬∑t‚ÇÉ))¬∑((ind_‚ãÉ‚ÇÅ¬∑t‚ÇÇ)¬∑t‚ÇÉ)

open conversion                                 -- a tirar

def Conv1 (t‚ÇÅ t‚ÇÇ : Term) := (((Œ†‚ÇÅ¬∑t‚ÇÅ)¬∑t‚ÇÇ) = t‚ÇÅ)
def Conv2 (t‚ÇÅ t‚ÇÇ t‚ÇÉ : Term) := ((((Œ£‚ÇÅ¬∑t‚ÇÅ)¬∑t‚ÇÇ)¬∑t‚ÇÉ) = ((t‚ÇÅ¬∑t‚ÇÉ)¬∑(t‚ÇÇ¬∑t‚ÇÉ)))
def Conv3 (t‚ÇÅ t‚ÇÇ : Term) := (((ind_‚ãÉ‚ÇÅ¬∑(ùî∞‚ÇÅ¬∑t‚ÇÅ))¬∑t‚ÇÇ) = (t‚ÇÇ¬∑t‚ÇÅ))
def Conv4 (t‚ÇÅ t‚ÇÇ t‚ÇÉ : Term) := (((ind_‚ãÉ‚ÇÅ¬∑((‚à™‚ÇÅ¬∑t‚ÇÅ)¬∑t‚ÇÇ))¬∑t‚ÇÉ) = ((‚à™‚ÇÅ¬∑((ind_‚ãÉ‚ÇÅ¬∑t‚ÇÅ)¬∑t‚ÇÉ))¬∑((ind_‚ãÉ‚ÇÅ¬∑t‚ÇÇ)¬∑t‚ÇÉ)))

lemma Conv1_l (t‚ÇÅ t‚ÇÇ : Term) : (((Œ†‚ÇÅ¬∑t‚ÇÅ)¬∑t‚ÇÇ) = t‚ÇÅ) := by sorry
lemma Conv2_l (t‚ÇÅ t‚ÇÇ t‚ÇÉ : Term) : ((((Œ£‚ÇÅ¬∑t‚ÇÅ)¬∑t‚ÇÇ)¬∑t‚ÇÉ) = ((t‚ÇÅ¬∑t‚ÇÉ)¬∑(t‚ÇÇ¬∑t‚ÇÉ))) := by sorry
lemma Conv3_l (t‚ÇÅ t‚ÇÇ : Term) : (((ind_‚ãÉ‚ÇÅ¬∑(ùî∞‚ÇÅ¬∑t‚ÇÅ))¬∑t‚ÇÇ) = (t‚ÇÇ¬∑t‚ÇÅ)) := by sorry
lemma Conv4_l (t‚ÇÅ t‚ÇÇ t‚ÇÉ : Term) : (((ind_‚ãÉ‚ÇÅ¬∑((‚à™‚ÇÅ¬∑t‚ÇÅ)¬∑t‚ÇÇ))¬∑t‚ÇÉ) = ((‚à™‚ÇÅ¬∑((ind_‚ãÉ‚ÇÅ¬∑t‚ÇÅ)¬∑t‚ÇÉ))¬∑((ind_‚ãÉ‚ÇÅ¬∑t‚ÇÇ)¬∑t‚ÇÉ))) := by sorry


-- (((ind_‚ãÉ‚ÇÅ¬∑(ùî∞‚ÇÅ¬∑t‚ÇÅ))¬∑t‚ÇÇ) =‚ÇÅ (t‚ÇÇ¬∑t‚ÇÅ))
--(((ind_‚ãÉ‚ÇÅ¬∑((‚à™‚ÇÅ¬∑(var x‚ÇÅ))¬∑(var x‚ÇÇ)))¬∑(var x‚ÇÉ)) =‚ÇÅ ((‚à™‚ÇÅ¬∑((ind_‚ãÉ‚ÇÅ¬∑(var x‚ÇÅ))¬∑(var x‚ÇÉ)))¬∑((ind_‚ãÉ‚ÇÅ¬∑(var x‚ÇÇ))¬∑(var x‚ÇÉ))))

-- Para exemplos
def CC_var_eq : Term := ((Œ£‚ÇÅ¬∑Œ†‚ÇÅ)¬∑Œ†‚ÇÅ)
def CC_var_dif : Term := ((Œ£‚ÇÅ¬∑Œ†‚ÇÅ)¬∑Œ†‚ÇÅ)
def CC_const : Term := ((Œ£‚ÇÅ¬∑Œ†‚ÇÅ)¬∑Œ†‚ÇÅ)

/--/
lemma cenass (x : String) (s : Term) (c : LTerm) : ((lcons c)=((lcons c).subst ([x]‚üπ[s]))) :=
by
  rw [Term.subst]
  rw [remove_non_l_terms]
  sorry
-/

-- Igualdades entre termos s√£o igualdades  -- TBD: seria necess√°rio definir substitui√ß√£o de termos por termos
lemma eq_are_eq {Œì : Set Formula} (t q : Term) (h: Œì ‚ä¢ t=‚ÇÅq): t=q := by sorry

-- OLD (a tirar)
theorem combinatorial_completeness (x : String) : ‚àÄ(t:Term), ‚àÉ(q:Term), ‚àÄ(s:Term),
  (Œì ‚ä¢ ((q¬∑s) =‚ÇÅ (t.subst ([x] ‚üπ [s])))) :=
by
  intro t
  cases t with
  | lcons _ =>
      rename_i c
      existsi ((la x (lcons c)).to_term)    --existsi Œ†‚ÇÅ¬∑(lcons c)
      intro s
      rw [to_term]
      have H1 := Conv1_l (lcons c) s
      rw [H1]                         -- precisamos de:    Œì ‚ä¢ lcons c=‚ÇÅ(lcons c).subst ([x]‚üπ[s])
      rw [Term.subst]
      --rw [remove_non_l_terms]
      sorry
  | lfun _ => sorry
  | pi =>
      existsi ((la x Œ†‚ÇÅ).to_term)     -- em vez de:  existsi Œ†‚ÇÅ¬∑Œ†‚ÇÅ
      intro s
      rw [to_term]
      have H1 := Conv1_l Œ†‚ÇÅ s
      rw [H1]
      rw [Term.subst]                  -- precisamos de:   Œì ‚ä¢ Œ†‚ÇÅ=‚ÇÅŒ†‚ÇÅ
      --have H2 := ProvableFrom.subs ( Œ†‚ÇÅ =‚ÇÅ Œ†‚ÇÅ )
      sorry
  | sigma =>
      existsi ((la x Œ£‚ÇÅ).to_term)      --existsi Œ†‚ÇÅ¬∑Œ£‚ÇÅ
      intro s
      rw [to_term]
      have H1 := Conv1_l Œ£‚ÇÅ s
      rw [H1]
      rw [Term.subst]                   -- precisamos de:   Œì ‚ä¢ Œ£‚ÇÅ=‚ÇÅŒ£‚ÇÅ
      sorry
  | sing =>
      existsi ((la x ùî∞‚ÇÅ).to_term)       --existsi Œ†‚ÇÅ¬∑ùî∞‚ÇÅ
      intro s
      rw [to_term]
      have H1 := Conv1_l ùî∞‚ÇÅ s
      rw [H1]
      rw [Term.subst]                   -- precisamos de:   Œì ‚ä¢ ùî∞‚ÇÅ=‚ÇÅùî∞‚ÇÅ
      sorry
  | bUnion =>
      existsi ((la x ‚à™‚ÇÅ).to_term)       --existsi Œ†‚ÇÅ¬∑ùî∞‚ÇÅ
      intro s
      rw [to_term]
      have H1 := Conv1_l bUnion s
      rw [H1]
      rw [Term.subst]       -- precisamos de:   Œì ‚ä¢ ‚à™‚ÇÅ=‚ÇÅ‚à™‚ÇÅ
      sorry
  | iUnion =>
      existsi ((la x ind_‚ãÉ‚ÇÅ).to_term)       --existsi Œ†‚ÇÅ¬∑ùî∞‚ÇÅ
      intro s
      rw [to_term]
      have H1 := Conv1_l iUnion s
      rw [H1]
      rw [Term.subst]       -- precisamos de:   Œì ‚ä¢ ind_‚ãÉ‚ÇÅ=‚ÇÅind_‚ãÉ‚ÇÅ
      sorry
  | var y =>
      by_cases h: x = y
      . existsi ((la x (var y)).to_term)       --existsi Œ†‚ÇÅ¬∑ùî∞‚ÇÅ
        intro s
        rw [to_term]
        simp [h]
        --existsi ((Œ£‚ÇÅ¬∑Œ†‚ÇÅ)¬∑Œ†‚ÇÅ)
        --intro s
        have H1 := Conv2_l Œ†‚ÇÅ Œ†‚ÇÅ s
        rw [H1]
        have H2 := Conv1_l s (Œ†‚ÇÅ¬∑s)
        rw [H2]
        unfold Term.subst           -- ‚ä¢ Œì ‚ä¢ s=‚ÇÅ([y]‚üπ[s]).findD y (var y)
        sorry
      . existsi ((la x (var y)).to_term)
        --existsi (Œ†‚ÇÅ¬∑(var y))
        intro s
        rw [to_term]
        simp [h]
        have H1 := Conv1_l (var y) s
        rw [H1]
        sorry               -- precisamos de:    ‚ä¢ Œì ‚ä¢ var y=‚ÇÅ(var y).subst ([x]‚üπ[s])
  | app t‚ÇÅ t‚ÇÇ => -- BY INDUCTION
      --existsi ((la x (t‚ÇÅ¬∑t‚ÇÇ)).to_term)
      --intro s
      --rw [to_term]
      sorry


-- OLD (a tirar)
theorem combinatorial_completeness2 (x : String) : ‚àÄ(t:Term), ‚àÉ(q:Term), ‚àÄ(s:Term),
  (Œì ‚ä¢ ((q¬∑s) =‚ÇÅ (t.subst ([x] ‚üπ [s])))) :=
by
  intro t
  induction t with
  | lcons _ => sorry
  | lfun _ => sorry
  | pi => sorry
  | sigma => sorry
  | sing =>
        existsi ((la x ùî∞‚ÇÅ).to_term)       --existsi Œ†‚ÇÅ¬∑ùî∞‚ÇÅ
        intro s
        rw [to_term]
        rw [Term.subst]
        exact AxC‚ÇÅ_term ùî∞‚ÇÅ s
        --exact ProvableFrom.AxC‚ÇÅ
  | bUnion => sorry
  | iUnion => sorry
  | var y =>
      by_cases h: x = y
      . existsi ((la x (var y)).to_term)   --existsi Œ†‚ÇÅ¬∑ùî∞‚ÇÅ
        intro s
        rw [to_term]
        simp [h]
        --existsi ((Œ£‚ÇÅ¬∑Œ†‚ÇÅ)¬∑Œ†‚ÇÅ)
        --intro s
        have H1 := Conv2_l Œ†‚ÇÅ Œ†‚ÇÅ s
        rw [H1]
        have H2 := Conv1_l s (Œ†‚ÇÅ¬∑s)
        rw [H2]
        unfold Term.subst           -- ‚ä¢ Œì ‚ä¢ s=‚ÇÅ([y]‚üπ[s]).findD y (var y)
        sorry
      . existsi ((la x (var y)).to_term)
        --existsi (Œ†‚ÇÅ¬∑(var y))
        intro s
        rw [to_term]
        simp [h]
        have H1 := Conv1_l (var y) s
        rw [H1]
        rw [Term.subst]
        sorry
  | app _ _ _ _ =>
        rename_i t‚ÇÅ t‚ÇÇ ht‚ÇÅ ht‚ÇÇ
        existsi ((la x (t‚ÇÅ¬∑t‚ÇÇ)).to_term)
        intro s
        rcases ht‚ÇÅ with ‚ü®q‚ÇÅ, hq‚ÇÅ‚ü©
        rcases ht‚ÇÇ with ‚ü®q‚ÇÇ, hq‚ÇÇ‚ü©
        have h‚ÇÅ := hq‚ÇÅ s
        have h‚ÇÇ := hq‚ÇÇ s
        rw [to_term]
        have H1 := Conv2_l ((la x t‚ÇÅ).to_term) ((la x t‚ÇÇ).to_term) s
        rw [H1]
        rw [Term.subst]
        have H1 := eq_are_eq (q‚ÇÅ¬∑s) (t‚ÇÅ.subst ([x]‚üπ[s])) h‚ÇÅ
        rw [‚Üê H1]
        have H2 := eq_are_eq (q‚ÇÇ¬∑s) (t‚ÇÇ.subst ([x]‚üπ[s])) h‚ÇÇ
        rw [‚Üê H2]
        sorry
        --rw [h‚ÇÅ, h‚ÇÇ]

lemma eq_to_subst :
  Œì ‚ä¢ (t‚ÇÅ =‚ÇÅ t‚ÇÇ) ‚Üí
  Œì ‚ä¢ t ‚Üí
  Œì ‚ä¢ (t.term_subst t‚ÇÅ t‚ÇÇ)
  := by sorry

lemma helper_cc1 : (([x]‚üπ[s]).findD c (lcons c)) = (lcons c) := by sorry
lemma helper_cc2 : (([x]‚üπ[s]).findD f (lfun f)) = (lfun f) := by sorry
lemma helper_cc3 : ((HashMap.ofList [(x, s)]).findD y (var y)) = (var y) := by sorry
lemma helper_cc4 (y:String) (s d :Term): ((HashMap.ofList [(y, s)]).findD y d) = s := by sorry
lemma helper_t {t‚ÇÅ t‚ÇÇ t‚ÇÉ : Term} : (Œì ‚ä¢ t‚ÇÅ =‚ÇÅ t‚ÇÇ) ‚Üí (Œì ‚ä¢ t‚ÇÇ =‚ÇÅ t‚ÇÉ) ‚Üí (Œì ‚ä¢ t‚ÇÅ =‚ÇÅ t‚ÇÉ) := by sorry
lemma helper_subst_l {t‚ÇÅ t‚ÇÇ t‚ÇÉ t‚ÇÇ' : Term} : (Œì ‚ä¢ t‚ÇÅ =‚ÇÅ (t‚ÇÇ¬∑t‚ÇÉ)) ‚Üí (Œì ‚ä¢ t‚ÇÇ =‚ÇÅ t‚ÇÇ') ‚Üí (Œì ‚ä¢ t‚ÇÅ =‚ÇÅ (t‚ÇÇ'¬∑t‚ÇÉ)) := by sorry
lemma helper_subst_r {t‚ÇÅ t‚ÇÇ t‚ÇÉ t‚ÇÉ' : Term} : (Œì ‚ä¢ t‚ÇÅ =‚ÇÅ (t‚ÇÇ¬∑t‚ÇÉ)) ‚Üí (Œì ‚ä¢ t‚ÇÉ =‚ÇÅ t‚ÇÉ') ‚Üí (Œì ‚ä¢ t‚ÇÅ =‚ÇÅ (t‚ÇÇ¬∑t‚ÇÉ')) := by sorry


-- good version
theorem CombinatorialCompleteness {x‚ÇÅ x‚ÇÇ x‚ÇÉ : String} (x:String) (s:Term):
  ‚àÄ(t:Term),
  (Œì ‚ä¢ ((((la x t).to_term)¬∑s) =‚ÇÅ (t.subst ([x] ‚üπ [s])))) :=
by
  intro t
  induction t with
  | lcons c =>
      rw [to_term, Term.subst]
      rw [helper_cc1]
      exact AxC‚ÇÅ_term (lcons c) s
  | lfun f =>
      rw [to_term, Term.subst]
      rw [helper_cc2]
      exact AxC‚ÇÅ_term (lfun f) s
  | pi =>
      rw [to_term, Term.subst]
      exact AxC‚ÇÅ_term Œ†‚ÇÅ s
  | sigma =>
      rw [to_term, Term.subst]
      exact AxC‚ÇÅ_term Œ£‚ÇÅ s
  | sing =>
      rw [to_term, Term.subst]
      exact AxC‚ÇÅ_term ùî∞‚ÇÅ s
  | bUnion =>
      rw [to_term, Term.subst]
      exact AxC‚ÇÅ_term ‚à™‚ÇÅ s
  | iUnion =>
      rw [to_term, Term.subst]
      exact AxC‚ÇÅ_term ind_‚ãÉ‚ÇÅ s
  | var y =>
      by_cases h: x = y
      . rw [to_term]
        simp [h]
        rw [Term.subst]           --  ‚ä¢   Œì ‚ä¢ (((Œ£‚ÇÅ¬∑Œ†‚ÇÅ)¬∑Œ†‚ÇÅ)¬∑s)=‚ÇÅ([y]‚üπ[s]).findD y (var y)
        rw [helper_cc4]
        have H1 := @AxC‚ÇÇ_term_l Œì x‚ÇÅ x‚ÇÇ x‚ÇÉ Œ†‚ÇÅ Œ†‚ÇÅ s
        have H2 := @AxC‚ÇÅ_term_l Œì x‚ÇÅ x‚ÇÇ s (Œ†‚ÇÅ¬∑s)
        exact helper_t H1 H2    -- permitiu aplicar AxC2 e depois AxC1
      . rw [to_term]
        simp [h]
        rw [Term.subst]           --  ‚ä¢   Œì ‚ä¢ ((Œ†‚ÇÅ¬∑var y)¬∑s)=‚ÇÅ([x]‚üπ[s]).findD y (var y)
        rw [helper_cc3]
        exact AxC‚ÇÅ_term (var y) s
  | app t‚ÇÅ t‚ÇÇ ht‚ÇÅ ht‚ÇÇ =>
      rw [to_term]
      rw [Term.subst]
      have H1 := @AxC‚ÇÇ_term_l Œì x‚ÇÅ x‚ÇÇ x‚ÇÉ ((la x t‚ÇÅ).to_term) ((la x t‚ÇÇ).to_term) s
      have Hr := @helper_subst_l Œì (((Œ£‚ÇÅ¬∑(la x t‚ÇÅ).to_term)¬∑(la x t‚ÇÇ).to_term)¬∑s) (((la x t‚ÇÅ).to_term¬∑s)) ((la x t‚ÇÇ).to_term¬∑s) (t‚ÇÅ.subst ([x]‚üπ[s])) H1 ht‚ÇÅ
      exact @helper_subst_r Œì (((Œ£‚ÇÅ¬∑(la x t‚ÇÅ).to_term)¬∑(la x t‚ÇÇ).to_term)¬∑s) (t‚ÇÅ.subst ([x]‚üπ[s])) ((la x t‚ÇÇ).to_term¬∑s) (t‚ÇÇ.subst ([x]‚üπ[s])) Hr ht‚ÇÇ
